package generator

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

type Icon struct {
	Name       string
	PascalName string
	Paths      string
	Aliases    []Alias
}

type Alias struct {
	Name              string
	PascalName        string
	TargetName        string
	TargetPascalName  string
	DeprecationReason string
	Deprecated        bool
}

type iconMetadata struct {
	Aliases []struct {
		Name              string `json:"name"`
		DeprecationReason string `json:"deprecationReason,omitempty"`
		Deprecated        bool   `json:"deprecated,omitempty"`
	} `json:"aliases,omitempty"`
}

type Result struct {
	IconsGenerated int
	IconsAdded     []string
	IconsRemoved   []string
}

type Generator struct {
	IconsDir   string
	OutputFile string
}

// New creates a new Generator with the given icons directory and output file paths.
func New(iconsDir, outputFile string) *Generator {
	return &Generator{
		IconsDir:   iconsDir,
		OutputFile: outputFile,
	}
}

// Generate reads SVG files from the icons directory and generates the output Go file.
// Returns statistics about the generation process.
func (g *Generator) Generate() (*Result, error) {
	files, err := filepath.Glob(filepath.Join(g.IconsDir, "*.svg"))
	if err != nil {
		return nil, fmt.Errorf("failed to glob SVG files: %w", err)
	}

	if len(files) == 0 {
		return nil, fmt.Errorf("no SVG files found in %s", g.IconsDir)
	}

	icons := make([]Icon, 0, len(files))
	for _, file := range files {
		icon, err := processIcon(file, g.IconsDir)
		if err != nil {
			return nil, fmt.Errorf("failed to process %s: %w", file, err)
		}
		icons = append(icons, icon)
	}

	sort.Slice(icons, func(i, j int) bool {
		return icons[i].Name < icons[j].Name
	})

	if err := generateFile(g.OutputFile, icons); err != nil {
		return nil, fmt.Errorf("failed to generate file: %w", err)
	}

	return &Result{
		IconsGenerated: len(icons),
	}, nil
}

func processIcon(svgPath string, iconsDir string) (Icon, error) {
	name := strings.TrimSuffix(filepath.Base(svgPath), ".svg")

	content, err := os.ReadFile(svgPath)
	if err != nil {
		return Icon{}, err
	}

	paths := extractSVGContent(string(content))

	icon := Icon{
		Name:       name,
		PascalName: toPascalCase(name),
		Paths:      paths,
	}

	metadataPath := filepath.Join(iconsDir, name+".json")
	if metadata, err := readMetadata(metadataPath); err == nil {
		for _, alias := range metadata.Aliases {

			aliasPascalName := toPascalCase(alias.Name)
			if aliasPascalName == icon.PascalName {
				continue
			}

			icon.Aliases = append(icon.Aliases, Alias{
				Name:              alias.Name,
				PascalName:        aliasPascalName,
				TargetName:        name,
				TargetPascalName:  icon.PascalName,
				DeprecationReason: alias.DeprecationReason,
				Deprecated:        alias.Deprecated,
			})
		}
	}

	return icon, nil
}

func readMetadata(path string) (*iconMetadata, error) {
	content, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var metadata iconMetadata
	if err := json.Unmarshal(content, &metadata); err != nil {
		return nil, err
	}

	return &metadata, nil
}

func extractSVGContent(svg string) string {
	startIdx := strings.Index(svg, ">")
	if startIdx == -1 {
		return ""
	}

	endIdx := strings.LastIndex(svg, "</svg>")
	if endIdx == -1 {
		return ""
	}

	content := svg[startIdx+1 : endIdx]
	content = strings.TrimSpace(content)

	re := regexp.MustCompile(`\s+`)
	content = re.ReplaceAllString(content, " ")

	return content
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	result := make([]string, len(parts))

	for i, part := range parts {
		if part == "" {
			continue
		}
		result[i] = strings.ToUpper(string(part[0])) + part[1:]
	}

	return strings.Join(result, "")
}

func generateFile(outputPath string, icons []Icon) error {
	var buf bytes.Buffer
	tmpl := template.Must(template.New("icons").Parse(iconTemplate))
	if err := tmpl.Execute(&buf, icons); err != nil {
		return err
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	return os.WriteFile(outputPath, formatted, 0o644)
}

const iconTemplate = `// Code generated by cmd/generate. DO NOT EDIT.

package lucide

import "html/template"

func init() {
{{- range . }}
	registerIcon("{{ .Name }}", {{ .PascalName }})
{{- range .Aliases }}
	registerIcon("{{ .Name }}", {{ .PascalName }})
{{- end }}
{{- end }}
}

{{- range . }}

// {{ .PascalName }} renders the "{{ .Name }}" icon.
//
// Usage in templates:
//   {{ "{{" }} lucide "{{ .Name }}" {{ "}}" }}
//
// Direct usage in Go:
//   lucide.{{ .PascalName }}()
//   lucide.{{ .PascalName }}(lucide.Options{Size: 32, Class: "my-icon"})
func {{ .PascalName }}(opts ...Options) template.HTML {
	opt := Options{Size: 24, StrokeWidth: 2}
	if len(opts) > 0 {
		opt = opts[0]
		if opt.Size == 0 {
			opt.Size = 24
		}
		if opt.StrokeWidth == 0 {
			opt.StrokeWidth = 2
		}
	}
	return buildSVG(` + "`" + `{{ .Paths }}` + "`" + `, opt)
}
{{- range .Aliases }}

// {{ .PascalName }} is an alias for {{ .TargetPascalName }}.
{{- if .Deprecated }}
//
// Deprecated: This icon name is deprecated and will be removed in a future version.
{{- if .DeprecationReason }}
// Reason: {{ .DeprecationReason }}
{{- end }}
// Please use {{ .TargetPascalName }} instead.
{{- end }}
//
// Usage in templates:
//   {{ "{{" }} lucide "{{ .Name }}" {{ "}}" }}
//
// Direct usage in Go:
//   lucide.{{ .PascalName }}()
//   lucide.{{ .PascalName }}(lucide.Options{Size: 32, Class: "my-icon"})
func {{ .PascalName }}(opts ...Options) template.HTML {
	return {{ .TargetPascalName }}(opts...)
}
{{- end }}
{{- end }}
`
