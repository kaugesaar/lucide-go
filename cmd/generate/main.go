package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

type Icon struct {
	Name       string
	PascalName string
	Paths      string
}

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	iconsDir := "lucide/icons"
	outputFile := "icons.go"

	fmt.Println("Reading icons from", iconsDir)

	files, err := filepath.Glob(filepath.Join(iconsDir, "*.svg"))
	if err != nil {
		return fmt.Errorf("failed to glob SVG files: %w", err)
	}

	if len(files) == 0 {
		return fmt.Errorf("no SVG files found in %s", iconsDir)
	}

	icons := make([]Icon, 0, len(files))
	for _, file := range files {
		icon, err := processIcon(file)
		if err != nil {
			return fmt.Errorf("failed to process %s: %w", file, err)
		}
		icons = append(icons, icon)
	}

	sort.Slice(icons, func(i, j int) bool {
		return icons[i].Name < icons[j].Name
	})

	fmt.Printf("Generating %d icons to %s\n", len(icons), outputFile)

	if err := generateFile(outputFile, icons); err != nil {
		return fmt.Errorf("failed to generate file: %w", err)
	}

	fmt.Println("Successfully generated", outputFile)
	return nil
}

func processIcon(filepath string) (Icon, error) {
	name := strings.TrimSuffix(filepath, ".svg")
	name = name[strings.LastIndex(name, "/")+1:]

	content, err := os.ReadFile(filepath)
	if err != nil {
		return Icon{}, err
	}

	paths := extractSVGContent(string(content))

	return Icon{
		Name:       name,
		PascalName: toPascalCase(name),
		Paths:      paths,
	}, nil
}

func extractSVGContent(svg string) string {
	startIdx := strings.Index(svg, ">")
	if startIdx == -1 {
		return ""
	}

	endIdx := strings.LastIndex(svg, "</svg>")
	if endIdx == -1 {
		return ""
	}

	content := svg[startIdx+1 : endIdx]
	content = strings.TrimSpace(content)

	re := regexp.MustCompile(`\s+`)
	content = re.ReplaceAllString(content, " ")

	return content
}

func toPascalCase(s string) string {
	parts := strings.Split(s, "-")
	result := make([]string, len(parts))

	for i, part := range parts {
		if part == "" {
			continue
		}
		result[i] = strings.ToUpper(string(part[0])) + part[1:]
	}

	return strings.Join(result, "")
}

func generateFile(outputPath string, icons []Icon) error {
	// Generate code to buffer first
	var buf bytes.Buffer
	tmpl := template.Must(template.New("icons").Parse(iconTemplate))
	if err := tmpl.Execute(&buf, icons); err != nil {
		return err
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("failed to format generated code: %w", err)
	}

	// Write formatted code to file
	return os.WriteFile(outputPath, formatted, 0644)
}

const iconTemplate = `// Code generated by cmd/generate. DO NOT EDIT.

package lucide

import "html/template"

func init() {
{{- range . }}
	registerIcon("{{ .Name }}", {{ .PascalName }})
{{- end }}
}

{{- range . }}

// {{ .PascalName }} renders the "{{ .Name }}" icon.
//
// Usage in templates:
//   {{ "{{" }} lucide "{{ .Name }}" {{ "}}" }}
//
// Direct usage in Go:
//   lucide.{{ .PascalName }}()
//   lucide.{{ .PascalName }}(lucide.Options{Size: 32, Class: "my-icon"})
func {{ .PascalName }}(opts ...Options) template.HTML {
	opt := Options{Size: 24, StrokeWidth: 2}
	if len(opts) > 0 {
		opt = opts[0]
		if opt.Size == 0 {
			opt.Size = 24
		}
		if opt.StrokeWidth == 0 {
			opt.StrokeWidth = 2
		}
	}
	return buildSVG(` + "`" + `{{ .Paths }}` + "`" + `, opt)
}
{{- end }}
`
